# PA4-3-2 Count Hard Report

给出了一个快速排序 + 插入排序的排序代码，求出“比较操作”的总次数。

由于代码中的排序是稳定的，我们可以把序列简化为一个 $n$ 的排列，设第 $i$ 个元素是 $a_i$，元素 $k$ 的下标是 $c_k$。

快速排序本质上是对值域做分治，我们可以用值域区间 $[l, r]$ 代替代码中给出的下标区间 $[L, R]$。又因为排序的稳定性，递归到 $[l, r]$ 时这些元素的相对顺序和原序列中相同，因此我们不需要真的进行交换操作。对于 `int pivot = array[L]`，即找到值在 $[l, r]$ 区间内、下标最小的元素，而这个操作本质上是 $\{c_i\}_{i = 1}^{n}$ 序列中的区间最小值，使用线段树即可。找到这个元素的下标后，又可以在 $\{a_i\}_{i = 1}^{n}$ 序列中找到真实值 $k$，递归计算值域 $[l, k)$ 和 $(k, r]$ 即可。

当值域大小达到 $lim$ 限制后调用插入排序，其比较次数等于逆序对数量。此时需要注意到，$a_i$ 序列中的逆序对和 $c_k$ 序列中逆序对是一一对应的：$a_i = p, a_j = q$ 构成逆序对当且仅当 $(i, p)$ 和 $(j, q)$ 不构成二维偏序，而 $c_p = i, c_q = j$ 构成逆序对当且仅当 $(p, i)$ 和 $(q, j)$ 不构成二维偏序。因此我们只需要对 $c_i\ (l \le i \le r)$ 求逆序对，使用树状数组即可。

时间复杂度：$\mathcal O(n \log n)$

空间复杂度：$\mathcal O(n)$

---

困难和参考资料：无

用时：1h
