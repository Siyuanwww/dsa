# LAB1 Report

作者：丁思源 2022012901

## 时间复杂度

假设某个评测系统在测试程序时每秒钟执行 $10^8$ 条指令，选手程序不超过标准程序的指令数两倍都可以在 1s 内运行完。

标准程序需要 $10n^2$ 条指令时，选手最多 $20n^2$ 条，令 $20n^2 = 10^8$ 得到 $n = 2236$。

标准程序需要 $20n \log_2 n$ 条指令时，选手最多 $40n \log_2 n$ 条，令 $40n \log_2 n = 10^8$ 得到 $n = 145746$。

标准程序需要 $20n \log_2 m$ 条指令时，选手最多 $40n \log_2 m$ 条，为了保证选手的程序拥有合理的时间复杂度，需要从小到大、按照合适的跨度设置不同的 $n$（两端应相对密集一些），并计算对应的 $m$。（这样的数据点设置可能并不适合竞赛风格的“梯度数据、梯度得分”，但是可以很好地筛选出时间复杂度表达式为 $\mathcal O(n \log m)$ 的代码。）

| Data | $n$ | $m$ |
| :--- | :--- | :--- |
| 1 | $1$ | $2^{2,500,000}$ |
| 2 | $2$ | $2^{1,250,000}$ |
| 3 | $4$ | $2^{625,000}$ |
| 4 | $8$ | $2^{312,500}$ |
| 5 | $10$ | $2^{250,000}$ |
| 6 | $20$ | $2^{125,000}$ |
| 7 | $40$ | $2^{62,500}$ |
| 8 | $100$ | $2^{25,000}$ |
| 9 | $500$ | $2^{5,000}$ |
| 10 | $1,000$ | $2^{2,500}$ |
| 11 | $5,000$ | $2^{500}$ |
| 12 | $10,000$ | $2^{250}$ |
| 13 | $20,000$ | $2^{125}$ |
| 14 | $50,000$ | $2^{50}$ |
| 15 | $100,000$ | $2^{25}$ |
| 16 | $250,000$ | $1,024$ |
| 17 | $500,000$ | $32$ |
| 18 | $625,000$ | $16$ |
| 19 | $1,250,000$ | $4$ |
| 20 | $2,500,000$ | $2$ |

关于假设“执行一条指令的用时是确定的”，实际计算机的指令执行受到硬件和软件的性能影响，实际的执行用时会有波动。但是当我们忽略这种波动，并在平均意义上、在特定的某台计算机上考虑部指令的用时，这种假设还是合理的。

---

## 调试和测试

在 `solution_1.cpp` 中，存在 3 个 Bug，分别是 `matrix` 数组下标范围太小了（找到的方法：在极限数据下会 Runtime Error），修改成 `matrix[2005][2005]`；每次询问前 `sum` 变量没有初始化为 `0`（找到的方法：每次输出的结果是累加的值）；`sum` 的变量类型应为 `long long` 或 `unsigned long long`（找到的方法：极限数据会整型溢出）。

在 `solution_2.cpp` 中，除了之前提到了三类 Bug，询问时计算每行的前缀和 `rowsum[x+j][y+b] - rowsum[x+j][y]` 有问题，计算区间 $[y, y+b)$ 的正确写法是 `rowsum[x+j][y+b-1] - rowsum[x+j][y-1]`（找到的方法：瞪眼调试法）。

在调试过程中，可以使用命令 `gdb solution_1` 进入调试，使用 `b num` 在第 `num` 行添加断点，使用 `n`（next）单步执行，使用 `s`（step）单步执行并进入函数体，使用 `r` 直接运行程序并在断点处停止。

在 `rand_input.cpp` 中，`srand(time(0))` 表示使用当前系统时间（单位：秒）初始化随机数种子，用于生成一系列伪随机数。

在 `battle.cpp` 中，`g++ xxx.cpp -o xxx` 将 `xxx.cpp` 编译成可执行文件，`./rand_input > rand.in` 随机生成输入数据并输出到 `rand.in`，`./check_input < rand.in` 检查输入数据是否合法，`./solution_1 < rand.in > 1.out` 执行 `solution_1` 并将输入流重定向至 `rand.in`、将输出流重定向至 `1.out`（命令 `./solution_2 < rand.in > 2.out` 同理），`diff 1.out 2.out` 判断两个输出文件的内容是否相同。

命令行参数 `argv[0]` 表示被执行的文件本身的文件名。

在 link 文件夹中，可以使用 `g++ solve1.cpp solve2.cpp main.cpp -o main` 来链接编译，并用 `./main 1` 或 `./main 2` 分别使用第 1、2 种算法运行。补全的 `solve1()` 和 `solve2()` 函数体如下（前提是修改了 `main.cpp` 中数组大小和变量类型的 Bug）：

```cpp
typedef long long int64;
int64 solve1(int* matrix,int n,int m,int x,int y,int a,int b){
    int64 ans = 0;
    for (int i = x; i < x + a; i++) {
        for (int j = y; j < y + b; j++) {
            ans += *(matrix + (i * 2005) + j);
        }
    }
    return ans;
}
```

```cpp
typedef long long int64;
int64 solve2(int* matrix,int n,int m,int x,int y,int a,int b){
    static bool initiated = false;
    static int64 sum[2005][2005];
    if (!initiated) {
        initiated = true;
        for (int i = 1; i <= n; i++) {
            sum[i][0] = 0;
            for (int j = 1; j <= m; j++) {
                sum[i][j] = sum[i][j - 1] + *(matrix + i * 2005 + j);
            }
        }
    }
    int64 ans = 0;
    for (int i = x; i < x + a; i++) {
        ans += sum[i][y + b - 1] - sum[i][y - 1];
    }
    return ans;
}
```

---

## 优化和比较

按照 `solution_2.cpp` 优化的思路，考虑是否可以把一维前缀和拓展到二维情况。

定义 $sum(i, j)$ 表示前 $i$ 行、前 $j$ 列（大小为 $i \times j$ 的矩形）的元素之和。那么以 $(a, b)$ 为左上角、$(c, d)$ 为右下角的矩形的元素之和可以表示为：
$$
sum(c, d) - sum(a - 1, d) - sum(c, b - 1) + sum(a - 1, b - 1)
$$

最后加上 $sum(a - 1, b - 1)$ 是因为左上角的这块矩形被减去了两次（容斥原理）。

构造测试数据以对比三份代码的运行效率：

| Data | $n$ | $m$ | $q$ | solution_1 | solution_2 | solution_3 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | $20$ | $20$ | $100000$ | 80ms | 79ms | 77ms |
| 2 | $100$ | $100$ | $100000$ | 103ms | 87ms | 83ms |
| 3 | $2000$ | $2000$ | $10$ | 990ms | 970ms | 985ms |
| 4 | $200$ | $2000$ | $100000$ | 776ms | 194ms | 191ms |
| 5 | $2000$ | $200$ | $100000$| 13046ms | 877ms | 193ms |
| 6 | $1000$ | $1000$ | $100000$ | 24165ms | 521ms | 355ms |
| 7 | $2000$ | $2000$ | $100000$ | 96458ms | 1426ms | 1189ms |

为了尽可能最小化数据的随机性造成的实际时间复杂度和理论值的偏差，也为了尽可能最小化 `-O2` 优化对程序性能比较的影响，第 3~7 两组数据的 `x y a b` 均在极限数据 `1 1 n m` 的基础上做了大小为 $10$ 的随机偏移。

根据比较，在 $n, m$ 较小（第 1、2 组）或者 $q$ 较小（第 3 组）的情况下，三份代码的效率偏差无几（在测试过程中发现，在开启 `-O2` 优化之后，第 3 份代码甚至可能因为预处理的更大常数、查询时的内存寻址不连续造成的 Cache miss 带来相对更大的时间消耗）。

在 $m, q$ 较大但是 $n$ 不大（第 4 组）的情况下，第 3 份代码相比第 1 份效率有很大提升，但是和第 2 份差距不大。

当 $n, m, q$ 都接近限定的最大值时，尤其在每次询问的矩形接近整个矩形时（第 6、7 组），第 3 份会有最优的效率。但可能是由于 `-O2` 优化，和第 2 份代码的差距仍然不显著。

考虑到第 2 份代码的查询时间复杂度非常依赖 $n$，当我们把 $m$ 调小（第 5 组）后，第 3 份代码相对另外两份代码会取得非常显著的优势。

---

参考资料：

- 关于GDB的调试语句：<https://zhuanlan.zhihu.com/p/586155484>
